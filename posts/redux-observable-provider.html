<!doctype html>
<html lang="en"><head><title>Observable &amp; Provider Patterns in Redux</title><meta charset="utf-8"><meta content="width=device-width, initial-scale=1.0, viewport-fit=cover" name="viewport"><link href="https://josephjang.me/feed.xml" rel="alternate" title="josephjang.me posts feed" type="application/rss+xml"><meta content="Joseph Jang&#39;s blog" property="og:site_name"><meta content="Observable &amp; Provider Patterns in Redux" property="og:title"><meta content="website" property="og:type"><meta content="Redux still powers many production apps despite newer alternatives. Building Redux from scratch reveals how Observable and Provider patterns work together to manage state." property="og:description"><meta content="Redux still powers many production apps despite newer alternatives. Building Redux from scratch reveals how Observable and Provider patterns work together to manage state." name="description"><meta content="summary" property="twitter:card"><meta content="Observable &amp; Provider Patterns in Redux" property="twitter:title"><meta content="Redux still powers many production apps despite newer alternatives. Building Redux from scratch reveals how Observable and Provider patterns work together to manage state." property="twitter:description"><meta content="@josephjang" property="twitter:creator"><link as="font" crossorigin="true" href="Mona-Sans.woff2" rel="payload" type="font/woff2"><meta content="#cceac3" media="(prefers-color-scheme: light)" name="theme-color"><link href="/style.css" rel="stylesheet"><script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script><script src="/highlightjs-gleam.js"></script><script>hljs.highlightAll();</script></head><body><div class="limit-max-width-and-center"><article class="post h-entry "><header><h1 class="post-title p-name ">Observable &amp; Provider Patterns in Redux</h1><nav class="breadcrumbs"><a class="breadcrumb-link" href="/" rel="author">‚Üê home</a></nav><div class="post-subtitle"><time class="post-date dt-published " datetime="2024-02-23">23 February 2024</time><ul class="post-tags"><li class="post-tag p-category "><a href="/tags/javascript.html">javascript</a></li><li class="post-tag p-category "><a href="/tags/react.html">react</a></li></ul></div></header><main class="post-body e-content "><p>Redux has been around long enough that you&#39;ve probably used it, cursed at it, or at least heard coworkers complain about its boilerplate. Despite newer alternatives like React-Query, Jotai, and Recoil, Redux still runs in production apps everywhere.</p><p>The interesting thing about Redux isn&#39;t the action creators or reducers‚Äîit&#39;s the patterns underneath. Redux is built on two foundational patterns: Observable and Provider. Understanding these patterns explains not just how Redux works, but why it works the way it does.</p><div class="post-heading h2-title"><a class="clip" href="#the-observable-pattern" id="the-observable-pattern">üîó</a><h2>The Observable Pattern</h2></div><p>The Observable pattern is about watching for changes and letting interested parties know when something happens. Think of it like hosting a watch party‚Äîyou notify everyone when the next episode starts.</p><p>Here&#39;s how you might implement one:</p><pre><code class="not-prose language-jsx" data-lang="jsx">function createObservable() {
  let observers = []; // Array to store observers who will monitor state changes

  // Function to add an observer
  function subscribe(fn) {
    observers.push(fn); // Add the observer to the list

    // Return a function to unsubscribe, using closure to remember fn
    return function () {
      unSubscribe(fn);
    };
  }

  // Function to unsubscribe an observer
  function unSubscribe(fn) {
    observers = observers.filter((ob) =&gt; ob !== fn); // Remove the specified observer
  }

  // Function to notify all observers of a state change
  function notify(value) {
    if (observers.length === 0) {
      console.log(&#39;---- Sorry, no more subscriptions ----&#39;);
      return;
    }

    observers.forEach((ob) =&gt; {
      ob(value); // Call each observer function with the new value
    });
  }

  return {
    subscribe,
    unSubscribe,
    notify,
  };
}
</code></pre><p>The <code>subscribe</code> function returns an unsubscribe function that remembers which observer to remove later. This is handy when you&#39;re using anonymous functions‚Äîotherwise you&#39;d need to store a reference to unsubscribe.</p><pre><code class="not-prose language-jsx" data-lang="jsx">const observable = createObservable();

const unsubscribe = observable.subscribe((value) =&gt; {
  console.log(&#39;Received value from observer: &#39;, value);
});

observable.notify(&#39;Tada!!&#39;); // Output: Received value from observer: Tada!!

unsubscribe();

observable.notify(&#39;Tada!!&#39;); // No output</code></pre><p>The first <code>notify</code> call reaches the observer and logs the message. After unsubscribing, the second call goes nowhere.</p><p>Going back to the watch party analogy: you&#39;re the host managing who gets updates about new episodes. Friends can join your notification list (subscribe), you tell everyone when episodes are available (notify), and friends can leave the list anytime (unsubscribe). The Observable pattern works the same way‚Äîit&#39;s just a more formal way of organizing who gets told about what.</p><div class="post-heading h2-title"><a class="clip" href="#redux-as-an-observable" id="redux-as-an-observable">üîó</a><h2>Redux as an Observable</h2></div><p>Redux is essentially an Observable with some extra features. The store holds state, components subscribe to changes, and when you dispatch an action, all subscribers get notified. Here&#39;s what a minimal Redux implementation looks like:</p><pre><code class="not-prose language-jsx" data-lang="jsx">// createStore function: Takes a reducer and an initial state to create the store
function createStore(reducer, initialState) {
  let state = initialState; // Current state of the store
  let listeners = []; // List of listeners to notify on state change

  // Function to get the current state
  function getState() {
    return state;
  }

  // Function to subscribe a listener to state changes
  function subscribe(listener) {
    listeners.push(listener); // Add the listener to the list
    // Return a function to unsubscribe, using closure to remember the listener
    return function () {
      unSubscribe(listener);
    };
  }

  // Function to unsubscribe a listener
  function unSubscribe(listener) {
    listeners = listeners.filter((lis) =&gt; lis !== listener); // Remove the specified listener
  }

  // Function to dispatch an action and notify listeners of state changes
  function dispatch(action) {
    state = reducer(state, action); // Update state using the reducer
    listeners.forEach((listener) =&gt; {
      listener(); // Notify all listeners of the state change
    });
  }

  // Return the public methods of the store
  return {
    getState, // Get the current state
    dispatch, // Dispatch an action
    subscribe, // Subscribe to state changes
    unSubscribe, // Unsubscribe from state changes
  };
}
</code></pre><p>The key difference from our basic Observable is the <code>dispatch</code> method‚Äîit runs the action through a reducer to get the new state, then notifies all listeners. Everything else works the same way.</p><div class="post-heading h2-title"><a class="clip" href="#using-redux-in-react" id="using-redux-in-react">üîó</a><h2>Using Redux in React</h2></div><p>Here&#39;s how you&#39;d use our Redux implementation in a React component:</p><pre><code class="not-prose language-jsx" data-lang="jsx">const store = createStore((state = 0, action) =&gt; {
  const { type, payload } = action;
  switch (type) {
    case &#39;INCREMENT&#39;:
      return state + payload;
    case &#39;DECREMENT&#39;:
      return state - payload;
    default:
      return state;
  }
}, 0);</code></pre><pre><code class="not-prose language-jsx" data-lang="jsx">// App function component
function App() {
  // useState hook to manage the component&#39;s state (count). Initial value is the store&#39;s state.
  const [count, setCount] = useState(store.getState());

  // onClick function: Called when the button is clicked. Dispatches an &#39;INCREMENT&#39; action to increase the count.
  const onClick = () =&gt; {
    store.dispatch({ type: &#39;INCREMENT&#39;, payload: 1 });
  };

  // useEffect hook to subscribe to the store when the component mounts.
  useEffect(() =&gt; {
    // Subscribe to the store and update the component&#39;s state whenever the store&#39;s state changes.
    const unsubscribe = store.subscribe(() =&gt; {
      const newCount = store.getState();
      setCount(newCount);
    });
    return unsubscribe; // Return the unsubscribe function to clean up the subscription.
  }, []); // Empty dependency array to ensure this runs only once when the component mounts.

  // Render the component UI
  return (
    &lt;div className=&quot;App&quot;&gt;
      &lt;h1&gt;COUNTER&lt;/h1&gt;
      &lt;span&gt;{count}&lt;/span&gt; {/* Display the current count */}
      &lt;div style={{ marginTop: &#39;10px&#39; }}&gt;
        &lt;button onClick={onClick}&gt;+&lt;/button&gt; {/* Button to increment the count */}
      &lt;/div&gt;
    &lt;/div&gt;
  );
}
</code></pre><p>The component subscribes to the store on mount and updates its local state whenever the store changes. It&#39;s a bit manual, but it works.</p><div class="post-heading h2-title"><a class="clip" href="#the-provider-pattern" id="the-provider-pattern">üîó</a><h2>The Provider Pattern</h2></div><p>The manual Redux approach works but gets tedious quickly. You have to subscribe to the store in every component that needs state, manage subscriptions, and handle cleanup. React-Redux solves this with the Provider pattern.</p><p>The Provider pattern uses React&#39;s Context API to make the Redux store available to any component in the tree without manually passing it down. Here&#39;s the basic idea:</p><pre><code class="not-prose language-jsx" data-lang="jsx">import React, { createContext, useContext } from &#39;react&#39;;

const MessageContext = createContext();

export function MessageProvider({ children }) {
  const message = &#39;Hello from Context!&#39;;
  return (
    &lt;MessageContext.Provider value={message}&gt;
      {children}
    &lt;/MessageContext.Provider&gt;
  );
}

function ChildComponent() {
  const message = useContext(MessageContext);
  return &lt;div&gt;{message}&lt;/div&gt;;
}</code></pre><p>Any component inside <code>MessageProvider</code> can access the message without prop drilling. This same pattern works for Redux stores.</p><div class="post-heading h2-title"><a class="clip" href="#building-react-redux" id="building-react-redux">üîó</a><h2>Building React-Redux</h2></div><p>Here&#39;s how you&#39;d implement the essential parts of React-Redux:</p><pre><code class="not-prose language-jsx" data-lang="jsx">const StoreContext = createContext(null);

export function StoreProvider({ store, children }) {
  return (
    &lt;StoreContext.Provider value={store}&gt;{children}&lt;/StoreContext.Provider&gt;
  );
}

function useStore() {
  const context = useContext(StoreContext);
  if (!context) {
    throw new Error(&#39;useStore must be used within a StoreProvider&#39;);
  }
  return context;
}

export function useDispatch() {
  const store = useStore();
  return store.dispatch;
}

export function useSelector(selector) {
  const store = useStore();
  const [selectedState, setSelectedState] = useState(() =&gt;
    selector(store.getState())
  );

  useEffect(() =&gt; {
    const unsubscribe = store.subscribe(() =&gt; {
      const newState = selector(store.getState());
      setSelectedState(newState);
    });
    return unsubscribe;
  }, [store, selector]);

  return selectedState;
}</code></pre><p><code>useSelector</code> does the subscription management for you‚Äîit subscribes to the store, runs your selector function when the store changes, and triggers a re-render if the selected value changed.</p><p>Now instead of manually subscribing in every component, you can just use <code>useSelector</code> and <code>useDispatch</code>:</p><pre><code class="not-prose language-jsx" data-lang="jsx">function Counter() {
  const dispatch = useDispatch();
  const count = useSelector((state) =&gt; state);

  const onClick = () =&gt; {
    dispatch({ type: &#39;INCREMENT&#39;, payload: 1 });
  };

  return (
    &lt;div&gt;
      &lt;h1&gt;COUNTER&lt;/h1&gt;
      &lt;span&gt;{count}&lt;/span&gt;
      &lt;button onClick={onClick}&gt;+&lt;/button&gt;
    &lt;/div&gt;
  );
}</code></pre><p>Much cleaner than the manual subscription approach.</p><div class="post-heading h2-title"><a class="clip" href="#patterns-all-the-way-down" id="patterns-all-the-way-down">üîó</a><h2>Patterns All the Way Down</h2></div><p>Redux might seem complex with all its action creators, middleware, and boilerplate, but at its core it&#39;s just two simple patterns working together. The Observable pattern handles the subscription logic, and the Provider pattern handles getting the store to your components without passing it everywhere.</p><p>Understanding these patterns explains why Redux works the way it does, and why it&#39;s been so durable despite all the &quot;Redux killers&quot; that have come along. The patterns are solid‚Äîthey just sometimes get buried under layers of abstraction and tooling.</p><hr><p>References:</p><ul><li><p><a href="https://medium.com/@guokai83524/building-redux-from-scratch-e12eb0e484c8"><strong>Building Redux from scratch</strong></a></p></li><li><p><a href="https://zapier.com/engineering/how-to-build-redux/"><strong>JavaScript</strong>:¬†<em>Build Yourself a Redux</em></a></p></li><li><p><a href="https://www.jamasoftware.com/blog/lets-write-redux/"><strong>JavaScript</strong>:¬†<em>Let‚Äôs Write Redux!</em></a></p></li><li><p><a href="https://www.patterns.dev/vanilla/provider-pattern">Provider pattern</a></p></li><li><p><a href="https://www.patterns.dev/vanilla/observer-pattern">Observer pattern</a></p></li></ul></main></article></div></body></html>