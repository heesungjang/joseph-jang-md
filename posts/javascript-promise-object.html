<!doctype html>
<html lang="en"><head><title>Understanding bind Through Promise Implementation</title><meta charset="utf-8"><meta content="width=device-width, initial-scale=1.0, viewport-fit=cover" name="viewport"><link href="https://josephjang.me/feed.xml" rel="alternate" title="josephjang.me posts feed" type="application/rss+xml"><meta content="Joseph Jang&#39;s blog" property="og:site_name"><meta content="Understanding bind Through Promise Implementation" property="og:title"><meta content="website" property="og:type"><meta content="Ever had JavaScript&#39;s `this` point to something unexpected? Let&#39;s build a Promise from scratch to see how `bind()` keeps `this` predictable in asynchronous code." property="og:description"><meta content="Ever had JavaScript&#39;s `this` point to something unexpected? Let&#39;s build a Promise from scratch to see how `bind()` keeps `this` predictable in asynchronous code." name="description"><meta content="summary" property="twitter:card"><meta content="Understanding bind Through Promise Implementation" property="twitter:title"><meta content="Ever had JavaScript&#39;s `this` point to something unexpected? Let&#39;s build a Promise from scratch to see how `bind()` keeps `this` predictable in asynchronous code." property="twitter:description"><meta content="@josephjang" property="twitter:creator"><link as="font" crossorigin="true" href="Mona-Sans.woff2" rel="payload" type="font/woff2"><meta content="#cceac3" media="(prefers-color-scheme: light)" name="theme-color"><link href="/style.css" rel="stylesheet"><script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script><script src="/highlightjs-gleam.js"></script><script>hljs.highlightAll();</script></head><body><div class="limit-max-width-and-center"><article class="post h-entry "><header><h1 class="post-title p-name ">Understanding bind Through Promise Implementation</h1><nav class="breadcrumbs"><a class="breadcrumb-link" href="/" rel="author">‚Üê home</a></nav><div class="post-subtitle"><time class="post-date dt-published " datetime="2024-02-21">21 February 2024</time><ul class="post-tags"><li class="post-tag p-category "><a href="/tags/javascript.html">javascript</a></li></ul></div></header><main class="post-body e-content "><p>Picture this: you&#39;re deep in JavaScript code, everything&#39;s working perfectly, and then <code>this</code> decides to point to something completely unexpected. Your carefully crafted object method suddenly thinks <code>this</code> is the global window object, and your code stops working.</p><p>If you&#39;ve been there (and let&#39;s be honest, who hasn&#39;t?), you&#39;ve probably wondered why JavaScript works this way. Today, we&#39;re going to dive into this chaos by building a Promise from scratch and discovering how <code>bind()</code> can be our lifeline when <code>this</code> goes rogue.</p><div class="post-heading h2-title"><a class="clip" href="#the-bind-lifeline" id="the-bind-lifeline">üîó</a><h2>The bind Lifeline</h2></div><p>JavaScript&#39;s <code>bind()</code> method fixes the <code>this</code> problem by locking in what <code>this</code> should be, regardless of how the function gets called later. Think of it like putting a name tag on a function. No matter where that function ends up, it remembers who it belongs to.</p><p>The party analogy works here: instead of spending all night correcting people who call you by the wrong name, you just wear a name tag. <code>bind()</code> is that name tag for functions.</p><p>Let&#39;s build our own version to see what&#39;s really happening under the hood:</p><pre><code class="not-prose language-jsx" data-lang="jsx">Function.prototype.vbind = function (newThis) {
  // First, a sanity check - we can&#39;t bind something that isn&#39;t a function
  if (typeof this !== &#39;function&#39;) {
    throw new Error(&quot;Cannot bind - target is not callable&quot;);
  }
  
  let boundTargetFunction = this; // Remember the original function
  let boundArguments = Array.prototype.slice.call(arguments, 1); // Grab any extra arguments
  
  // Here&#39;s the magic - return a new function that &quot;remembers&quot; everything
  return function boundFunction() {
    let targetArguments = Array.prototype.slice.call(arguments);
    return boundTargetFunction.apply(newThis, boundArguments.concat(targetArguments));
  };
};</code></pre><p>The interesting part is that we&#39;re returning a new function that &quot;remembers&quot; the original function and the <code>this</code> value we want. When this bound function gets called, it uses <code>apply()</code> to run the original function with our chosen context.</p><blockquote><p>üí° <code>boundFunction</code> is a closure. It remembers the variables from when it was created, even after <code>vbind</code> finishes. This is why it can still access <code>boundTargetFunction</code>, <code>newThis</code>, and <code>boundArguments</code> later.</p></blockquote><div class="post-heading h2-title"><a class="clip" href="#building-our-own-promise" id="building-our-own-promise">üîó</a><h2>Building Our Own Promise</h2></div><p>Building a Promise from scratch reveals why <code>bind</code> matters so much in asynchronous code. Promises need to call methods on their instance from within callback functions, which is exactly when <code>this</code> starts pointing to unexpected places.</p><pre><code class="not-prose language-jsx" data-lang="jsx">class VPromise {
  constructor(executionFunction) {
    this.promiseChain = []; // All the .then() handlers waiting in line
    this.handleError = () =&gt; {}; // Our error handler (starts as a no-op)

    // Here&#39;s the crucial part - bind these methods to THIS instance
    this.onResolve = this.onResolve.vbind(this);
    this.onReject = this.onReject.vbind(this);

    // Execute immediately, passing our bound methods as resolve/reject
    executionFunction(this.onResolve, this.onReject);
  }

  then(handler) {
    this.promiseChain.push(handler); // Add to the queue
    return this; // Return ourselves for chaining
  }

  error(handler) {
    this.handleError = handler; // Set our error handler
    return this; // Chainable goodness
  }

  onResolve(value) {
    let storedValue = value;
    try {
      // Run through all the .then() handlers in sequence
      this.promiseChain.forEach((nextFunction) =&gt; {
        storedValue = nextFunction(storedValue);
      });
    } catch (error) {
      this.onReject(error); // If anything breaks, handle the error
    }
  }

  onReject(error) {
    this.handleError(error); // Pass the error to our handler
  }
}</code></pre><div class="post-heading h2-title"><a class="clip" href="#using-vpromise" id="using-vpromise">üîó</a><h2>Using VPromise</h2></div><pre><code class="not-prose language-jsx" data-lang="jsx">function delayThenValue() {
  return new VPromise((resolve, reject) =&gt; {
    setTimeout(() =&gt; {
      if (true) {
        resolve(&#39;Asynchronous result&#39;);
      } else {
        reject(&#39;Error occurred&#39;);
      }
    }, 2000);
  });
}

delayThenValue()
  .then((value) =&gt; {
    console.log(value); // &quot;Asynchronous result&quot; after 2 seconds
  })
  .error((error) =&gt; {
    console.log(error); // Won&#39;t happen in this example
  });</code></pre><p>The <code>vbind</code> calls in the constructor are what make this work. Without them, the <code>onResolve</code> and <code>onReject</code> methods would lose their connection to the Promise instance when called asynchronously.</p><div class="post-heading h2-title"><a class="clip" href="#why-bind-saves-the-day" id="why-bind-saves-the-day">üîó</a><h2>Why bind Saves the Day</h2></div><p>Here&#39;s what would happen without those <code>vbind</code> calls: when <code>setTimeout</code> eventually calls our resolve function, it wouldn&#39;t be called as a method of our <code>VPromise</code> instance. Instead, it would be called as a standalone function, meaning <code>this</code> would probably point to the global object (or be <code>undefined</code> in strict mode).</p><p>Our carefully crafted <code>onResolve</code> method would suddenly have no idea what <code>this.promiseChain</code> or <code>this.handleError</code> are supposed to be. The whole thing would break with a cascade of undefined errors.</p><p>With <code>bind</code>, the methods stay connected to their original instance no matter how they&#39;re called.</p><div class="post-heading h2-title"><a class="clip" href="#the-bigger-picture" id="the-bigger-picture">üîó</a><h2>The Bigger Picture</h2></div><p>JavaScript gives you flexibility with <code>this</code>, but that flexibility means you need to be explicit about what you want. <code>bind</code> is how you tell JavaScript to stop being clever and just stick to what you specified.</p><p>It&#39;s one of those methods that seems pointless until you actually need it. Then you realize how much cleaner your asynchronous code becomes when you don&#39;t have to worry about <code>this</code> wandering off.</p><hr><p><strong>References:</strong></p><ul><li><p><a href="https://levelup.gitconnected.com/understand-javascript-promises-by-building-a-promise-from-scratch-84c0fd855720"><strong>JavaScript</strong>:¬†<em>Learn JavaScript Promises by Building a Promise from Scratch</em></a></p></li><li><p><a href="https://www.mauriciopoppe.com/notes/computer-science/computation/promises/"><strong>JavaScript</strong>:¬†<em>Implementing promises from scratch (TDD way)</em></a></p></li><li><p><a href="https://blog.usejournal.com/implement-your-own-call-apply-and-bind-method-in-javascript-42cc85dba1b"><strong>JavaScript</strong>:¬†<em>Implement your own‚Ää‚Äî‚Ääcall(), apply() and bind() method in JavaScript</em></a></p></li></ul></main></article></div></body></html>