<!doctype html>
<html lang="en"><head><title>Understanding Lambda Calculus: The Mathematics Behind Functional Programming</title><meta charset="utf-8"><meta content="width=device-width, initial-scale=1.0, viewport-fit=cover" name="viewport"><link href="https://josephjang.me/feed.xml" rel="alternate" title="josephjang.me posts feed" type="application/rss+xml"><meta content="Joseph Jang&#39;s blog" property="og:site_name"><meta content="Understanding Lambda Calculus: The Mathematics Behind Functional Programming" property="og:title"><meta content="website" property="og:type"><meta content="Lambda calculus is a mathematical model for understanding computation using just three simple rules. Created by Alonzo Church, it became the foundation for functional programming languages like OCaml and Haskell." property="og:description"><meta content="Lambda calculus is a mathematical model for understanding computation using just three simple rules. Created by Alonzo Church, it became the foundation for functional programming languages like OCaml and Haskell." name="description"><meta content="summary" property="twitter:card"><meta content="Understanding Lambda Calculus: The Mathematics Behind Functional Programming" property="twitter:title"><meta content="Lambda calculus is a mathematical model for understanding computation using just three simple rules. Created by Alonzo Church, it became the foundation for functional programming languages like OCaml and Haskell." property="twitter:description"><meta content="@josephjang" property="twitter:creator"><link as="font" crossorigin="true" href="Mona-Sans.woff2" rel="payload" type="font/woff2"><meta content="#cceac3" media="(prefers-color-scheme: light)" name="theme-color"><link href="/style.css" rel="stylesheet"><script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script><script src="/highlightjs-gleam.js"></script><script>hljs.highlightAll();</script></head><body><div class="limit-max-width-and-center"><article class="post h-entry "><header><h1 class="post-title p-name ">Understanding Lambda Calculus: The Mathematics Behind Functional Programming</h1><nav class="breadcrumbs"><a class="breadcrumb-link" href="/" rel="author">← home</a></nav><div class="post-subtitle"><time class="post-date dt-published " datetime="2024-08-17">17 August 2024</time><ul class="post-tags"><li class="post-tag p-category "><a href="/tags/functional-programming.html">functional-programming</a></li><li class="post-tag p-category "><a href="/tags/lambda-calculus.html">lambda-calculus</a></li></ul></div></header><main class="post-body e-content "><div class="post-heading h2-title"><a class="clip" href="#what-is-lambda-calculus?" id="what-is-lambda-calculus?">🔗</a><h2>What is Lambda Calculus?</h2></div><p>Lambda calculus is a mathematical model for understanding computation. Despite its intimidating name, it&#39;s built on just three simple rules that can express any computable function.</p><p>Lambda calculus has had a huge influence on functional programming languages like OCaml and Haskell. Understanding these basic rules helps explain why functional languages work the way they do.</p><div class="post-heading h2-title"><a class="clip" href="#the-three-rules-of-lambda-calculus" id="the-three-rules-of-lambda-calculus">🔗</a><h2>The Three Rules of Lambda Calculus</h2></div><div class="post-heading h3-title"><a class="clip" href="#1.-variables" id="1.-variables">🔗</a><h3>1. Variables</h3></div><p>You can use variables like x, y, z to represent values.</p><div class="post-heading h3-title"><a class="clip" href="#2.-abstraction" id="2.-abstraction">🔗</a><h3>2. Abstraction</h3></div><p>The λ (lambda) symbol lets you define something as a function. In lambda calculus, functions are the only basic data type.</p><p>The basic form is: <code>λ parameter.return</code></p><p>So <code>λx.x</code> represents the function f(x) = x, and <code>λx.λy.x</code> represents a function f(x, y) = x.</p><p>Lambda calculus uses a concept from mathematics called currying. Functional programming languages like OCaml have currying built in.</p><p>Currying is a method that breaks down functions that take multiple arguments into a chain of functions that each take only one argument. This makes functions easier to reuse by calling them repeatedly.</p><p>Instead of taking two arguments at once like <code>λ(x,y).x y</code>, lambda calculus uses the form <code>λx.λy.x y</code>.</p><div class="post-heading h3-title"><a class="clip" href="#3.-application" id="3.-application">🔗</a><h3>3. Application</h3></div><p>An expression wrapped with λ is a function. To use that function, you apply a value to it:</p><pre><code class="not-prose language-" data-lang>λx.λy.x y
= f(x, y) = x
= x(y)</code></pre><div class="post-heading h2-title"><a class="clip" href="#examples" id="examples">🔗</a><h2>Examples</h2></div><p><strong>Example 1:</strong></p><pre><code class="not-prose language-" data-lang>(λx.x) y
=&gt; f(x) = x
=&gt; x(y)</code></pre><p><strong>Example 2:</strong></p><pre><code class="not-prose language-" data-lang>(λx.(λy.x)) z
=&gt; f(x) = λy.x
=&gt; λy.z</code></pre><p><strong>Example 3:</strong></p><pre><code class="not-prose language-" data-lang>(λx.(λy.x y)) (λx.x) (z)
=&gt; z</code></pre><div class="post-heading h2-title"><a class="clip" href="#the-big-problem" id="the-big-problem">🔗</a><h2>The Big Problem</h2></div><p>To use lambda calculus in programming languages, you need to handle basic data types like String, int, and Bool.</p><p>This problem was solved by American mathematician Alonzo Church (1903-1995). He invented Church Encoding to apply lambda numbers to Lambda Calculus.</p><div class="post-heading h2-title"><a class="clip" href="#church-encoding" id="church-encoding">🔗</a><h2>Church Encoding</h2></div><p>Church Encoding is a formalized way of modeling data and functions.</p><div class="post-heading h3-title"><a class="clip" href="#church-encoded-boolean-values" id="church-encoded-boolean-values">🔗</a><h3>Church-encoded Boolean Values</h3></div><p>Uses two arguments: returns the left argument when true, returns the right argument when false.</p><pre><code class="not-prose language-" data-lang>true = λa.λb.a   // if true, select parameter a
false = λa.λb.b  // if false, select parameter b</code></pre><div class="post-heading h3-title"><a class="clip" href="#church-encoded-natural-numbers" id="church-encoded-natural-numbers">🔗</a><h3>Church-encoded Natural Numbers</h3></div><pre><code class="not-prose language-" data-lang>pred(n) = (n=0) ? 0 : n-1</code></pre><p>Church encoding extends to other types like Maybe, Either, and more complex data structures, providing a way to represent any data type using only functions.</p><div class="post-heading h2-title"><a class="clip" href="#why-this-matters" id="why-this-matters">🔗</a><h2>Why This Matters</h2></div><p>Lambda calculus proves that computation can be reduced to simple function application. Every programming concept you use today can be expressed using just these three rules. It&#39;s the mathematical foundation that makes functional programming possible.</p><hr><p><strong>References:</strong></p><ul><li><p><a href="https://plato.stanford.edu/entries/lambda-calculus/">Lambda Calculus - Stanford Encyclopedia of Philosophy</a></p></li><li><p><a href="https://en.wikipedia.org/wiki/Alonzo_Church">Alonzo Church - Wikipedia</a></p></li></ul></main></article></div></body></html>